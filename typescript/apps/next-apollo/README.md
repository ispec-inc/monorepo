# Next-apollo App

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
cd ../../

yarn workspace @monorepo/next-apollo dev
```

Open <http://localhost:3000> with your browser to see the result.

## Stylyng

Reference to [unocss](https://github.com/unocss/unocss) [tailwind.css](https://tailwindcss.com/docs/installation)

# **Data Flow Architectue**

# Domain

## 背景

アプリケーションは、とあるドメイン(領域)の問題を解決するために開発するものである。

ドメインに関わる振る舞いは絶えず変化するものであるため、開発上においてはそれを集約し、ドメインを再現する必要がある。

その振る舞いはバックエンド側で定義されるものであり、フロントエンドおよびそのフレームワークはそのドメインに対する単なるユーザインターフェースとして機能させるのが理想である。

## 課題と目的

ドメインに関する実装に対してもバックエンドで扱いきれないものが出てくる。

それをフロントで扱う必要があるが、上記背景の通り、フロント側でもドメインに関する知識は適切に扱う必要がある。

## 実装

ドメインに関する知識は `domain/` 配下に集約して配置する。

可能な限りバックエンドで定義するべきものであるため、取り扱う必要が出てきた場合はバックエンド側にその実装を依頼する。

そのためフロントはこの層がスリムであることが理想である。

### value object

アプリケーションで扱う固有の値を定義する(email, phone-numberなど)。

定義の基準としては、そこにルールが存在する値について定義する。

不変な値であるため、setterを持たない

### entity

アプリケーションで扱うドメインのモデルを定義する。

`value object` とは違い、ライフサイクルの存在するモデルを定義する(userなど)。

`entity` の振る舞い(値の変化のルール)を定義し、想定しないドメインの振る舞いを制限する。

### domain service

`entity` で定義するには不自然なドメインの振る舞いをこの層で定義する。

### 参照

[DDDまとめ](https://www.notion.so/ispec/92549f51cc6b4da0b573474a8eb8061c)

# Hooks

`React` における `Custom Hook` を定義する。

また、アプリケーションサービス、およびそのユースケースを `Custom Hook` として定義する。

## 背景

アプリケーションではドメインの問題を解決するための活動を保有する。

それを我々はユースケースとして定義している。

## 課題と目的

アプリケーションロジックはフロントエンドフレームワーク上で各所に散らばりがちなものであり、変更されることも往々にしてある。

また、フレームワーク側に存在するUIに関するロジックにまぎれ、管理が煩雑になるものである。

よってそのアプリケーションロジックをサービス層として取りまとめ、 `React Custom Hooks` として表現することとしたい。

## 実装

ユースケースを `Custom Hook` として表現する。

ユースケースの例としては下記が挙げられる。

*   情報の表示
*   情報の作成、更新、アップデート
*   UI へのインタラクト

また、いくつか制約を持つ

*   状態は持たない(Apolloが持つ)
*   状態によって振る舞いは影響を受けない(状態に関係ない粒度でユースケースを分割する)

### 実装における課題

アプリケーションロジックはしばし煩雑なロジックを内包することが多い。

ユースケースの変更に柔軟に対応するためには、このhooksに存在するロジックはリーダブルに保つ必要がある。

そのために、後述の `Model` などの利用により、詳細なロジックはそれにカプセル化し、抽象的に扱うことでアプリケーションロジックをクリアに保つことを心がける。

## 代表的な Hooks

### Page hook

必要な情報を`Apollo`を操作して受け取り、UIへ渡す役割を持つ。

値の変換ロジックや、複雑な問い合わせが存在する場合は後述の `Query Model` を利用する。(原則的に利用する)

その他、error や loading状態 の受け渡しも行う。

### Mutate hook

情報の作成、更新、アップデートの操作を `Apollo` を操作してバックエンドに伝える役割を持つ。

値の変換ロジックの記載を減らしたり、関数のシグネチャの変更を一部にとどめるために、 `Mutate Model` をinterfaceとして持つ

その他、error や loading状態 の受け渡しも行う。

# Models

## 背景

アプリケーション上にはしばしば煩雑で複雑なロジックが存在することがある。

それらは可能な限り共通化し、一箇所にまとめておきたい。

## 課題と目的

それらのロジックを `Model` として取りまとめ、詳細な情報としてカプセル化することでより抽象的な取り扱いが可能になる結果、より変更に強いアプリケーションとなる。

例として挙げられるのが、特定のフレームワークへの依存度が高いロジックである。(apolloへの依存など)

それらへの依存を一手に引き受けることによっても、改修箇所がより明確で、影響範囲の限定された、変更に強いアプリケーションとすることができる。

## Apollo へ依存する Model

これらにより、UIの `Apollo` への結合を疎にすることができる。

それぞれ `/models/query` `/models/mutate` に定義する。

また、UIなどで詳細なロジックをカプセル化するために、適宜 `/models` にその他モデルを定義する。

### Query

UIが必要なデータを問い合わせるためのモデル。

`Apollo` に依存し、UIに必要な値を計算するためのロジックを集約し、UIへと渡される。

UI側で必要なデータは `/pages` 配下の `Container Component` によって同階層に interface として定義され、`Query Model` はそれを実装する。

*   interfaceに依存することで、UI側からは抽象概念に依存することができ、データのモッキングなどが容易になる。

### Mutate

`Apollo` に対して mutate をかける際に、そのロジックを集約させるるためのモデル。

UI側から instance化することによって、constructor のシグネチャ変更を `hooks` で行う必要性をなくす。

## 保守性について

複雑なロジックを model という形で集約することで、 testing が容易になる。

テストの価値が高まるロジックは、より複雑なロジックかと思われるが、それをこの model に定義し、 mock のデータを使って利用することでテストし、より信頼性の高いコードとすることができる。

適宜 graphql の mock データの generator などを利用してテストを行う。
