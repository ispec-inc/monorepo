# Next-apollo App

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
cd ../../

yarn workspace @monorepo/next-apollo dev
```

Open <http://localhost:3000> with your browser to see the result.

## Stylyng

Reference to [unocss](https://github.com/unocss/unocss) [tailwind.css](https://tailwindcss.com/docs/installation)

# **Data Flow Architectue**

# システムの構造

***

![システムの構造](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1da39d39-53a9-4250-ba70-9fa409406662/Untitled.png)

DDD(Domain Driven Design)を一部採用したレイヤードアーキテクチャ的な思想を元にシステムを組み立てる。

service層、model層、domain層、UI層の四層を持つ。

# アーキテクチャ特性

***

*   スケーラビリティを重要視する
    *   可読性
    *   重要なロジックの散在防止
*   テスト容易性を高める
    *   重要なロジックのカプセル化することでてスタビリティを高める
*   アジリティを可能な限り保障する
    *   レイヤリングの抑制によって
*   弾力性
    *   複数のプロダクトにある程度対応できるようなアーキテクチャ
*   学習容易性は比較的低い
    *   DDD
    *   Apollo Client
    *   React Hooks

# 設計指針

***

*   アーキテクチャでは、下記の二つの立場を分けて意識し、明確にする
    *   詳細なロジックを一箇所にまとめて記述してカプセル化する
    *   カプセル化された抽象概念を利用してコードの可読性を高める
    *   端的に言えば、オブジェクト指向的な考え方である。

# アーキテクチャ

***

# Domain

## 設計指針

### 背景

アプリケーションは、とあるドメイン(領域)の問題を解決するために開発するものである。

ドメインに関わる振る舞いは絶えず変化するものであるため、開発上においてはそれを集約し、ドメインを再現する必要がある。

その振る舞いはバックエンド側で定義されるものであり、フロントエンドおよびそのフレームワークはそのドメインに対する単なるユーザインターフェースとして機能させるのが理想である。

### 課題と目的

ドメインに関する実装に対してもバックエンドで扱いきれないものが出てくる。

それをフロントで扱う必要があるが、上記背景の通り、フロント側でもドメインに関する知識は適切に扱う必要がある。

ドメインのロジックが散在するとスケーラビリティその他が下がるため、一箇所に隔離する。

### 実装

ドメインに関する知識は `domain/` 配下に集約して配置する。

可能な限りバックエンドで定義するべきものであるため、取り扱う必要が出てきた場合はバックエンド側にその実装を依頼する。

そのためフロントはこの層がスリムであることが理想である。

定義の形は特に制限しない(class function など)

フロントエンドにおいては、ドメインに関するルールはUIの詳細なロジックであったり、値の変換、アプリケーションのユースケースなど他のどの層からも参照されうる。

バリデーションなどのドメイン知識ををUIのライブラリに沿って利用したい場合など、 `/util` などで定義したツールを利用して、適宜アクセスしやすくする。

## アーキテクチャルール

*   他のどの層からも依存される
*   他のどの層にも依存してはならない

### value object

*   アプリケーションで扱う固有の値を定義する(email, phone-numberなど)。
    *   定義の基準としては、そこにルールが存在する値について定義する。
*   不変な値であるため、setterを持たない

### entity

*   アプリケーションで扱うドメインのモデルを定義する。
*   `value object` とは違い、ライフサイクルの存在するモデルを定義する(userなど)。
*   `entity` の振る舞い(値の変化のルール)を定義し、想定しないドメインの振る舞いを制限する。

### domain service

*   `entity` で定義するには不自然なドメインの振る舞いをこの層で定義する。

### 参照

[DDDまとめ](https://www.notion.so/ispec/92549f51cc6b4da0b573474a8eb8061c)

# Service(Hooks)

`React` における `Custom Hook` を定義する。

## 設計指針

### 背景

アプリケーションではドメインの問題を解決するための活動を保有する。

それを我々はユースケースとして定義している。

### 課題と目的

アプリケーションロジックはフロントエンドフレームワーク上で各所に散らばりがちなものであり、変更されることも往々にしてある。

また、フレームワーク側に存在するUIに関するロジックにまぎれ、管理が煩雑になるものである。

よってそのアプリケーションロジックをサービス層として取りまとめ、 `React Custom Hooks` として表現することとしたい。

### 実装

ユースケースを `Custom Hooks`　のメソッドとして表現する。

ユースケースの例としては下記が挙げられる。

*   情報の表示
*   情報の作成、アップデート
*   UI へのインタラクト

### 実装における課題

アプリケーションロジックはしばし煩雑なロジックを内包することが多い。

ユースケースの変更に柔軟に対応するためには、このhooksに存在するロジックはリーダブルに保つ必要がある。

そのために、後述の `Model` などの利用により、詳細なロジックはそれにカプセル化し、抽象的に扱うことでアプリケーションロジックをクリアに保つことを心がける。

## アーキテクチャルール

*   アプリケーションサービス、およびそのユースケースを `Custom Hook` とそのメソッドとして定義する。
*   状態は可能な限り持たない(Apolloが持つ)
*   状態によって振る舞いは影響を受ける範囲を制限する(状態に関係ない粒度でユースケースを分割する。基本持たない)

### Page hook

*   必要な情報を `GraphQL` を操作して受け取り、UIへ渡す役割を持つ。
*   値の変換ロジックや、複雑な問い合わせが存在する場合は後述の `Query Model` を利用する。(原則的に利用する)
    *   Hooks の `useMemo` を適宜利用する
*   その他、error や loading状態 の受け渡しも行う。
*   基本的に `Apollo Client` をそのまま利用する
*   `Apollo Client` に追加してさらにロジックを挟んでUIに渡したい場合はそれをラップする `Custom Hook` を定義しても良い。
    *   周辺ファイルは `yarn hygen query new` で作成可能。

### Mutate hook

*   情報の作成、更新、アップデートの操作を `GraphQL` を操作してバックエンドに伝える役割を持つ。
*   値の変換ロジックの記載を隠蔽するために、 `Mutate Model` をinterfaceとして利用する
*   その他、error や loading状態 の受け渡しも行う。
*   `Apollo Client` に追加してさらにロジックを挟んで Mutate したい場合はそれをラップする `Custom Hook` を定義しても良い。
    *   周辺ファイルは `yarn hygen mutate new` で作成可能。

# Models

## 設計指針

### 背景

アプリケーション上にはしばしば煩雑で複雑なロジックが存在することがある。

例としては特定の技術に依存するロジック、およびUIで扱う意味単位での情報モデルでのロジックが挙げられる。

それらは可能な限り共通化し、一箇所にまとめておきたい。

### 課題と目的

*   それらのロジックを `Model` として取りまとめ、技術的関心事、および情報のロジックとしてカプセル化することでより抽象的な取り扱いが可能になる結果、より変更に強いアプリケーションとなる。
*   また、技術的関心を一手に引き受けることによっても、改修箇所がより明確で、影響範囲の限定された、変更に強いアプリケーションとすることができる。
*   UI と API層との結合を緩やかにする
*   複雑なロジックを model という形で集約することで、 testing を簡単に行えるようにする
    *   テストの価値が高まるロジックは、より複雑なロジックかと思われるが、それをこの model に定義し、 mock のデータを使って利用することでテストし、より信頼性の高いコードとすることができる。
    *   適宜 graphql の mock データの generator などを利用してテストを行う。

## アーキテクチャルール

*   Apollo に依存する技術的関心をカプセル化したモデルはそれぞれ `/models/query` `/models/mutate` に定義する。
*   また、UIなどで詳細なロジックをカプセル化するために、適宜 `/models` にその他モデルを定義する。

### Query

*   UIが必要なデータを問い合わせるためのモデルを定義する。
*   `Apollo` に依存し、UIに必要な値を計算する
*   UI側で必要なデータは `/pages` 配下の `Container Component` によって同階層に interface として定義され、`Query Model` はそれを実装する。
    *   interfaceに依存することで、UI側からは抽象概念に依存することができ、データのモッキングなどが容易になる。

### Mutate

*   `Apollo` に対して mutate をかける際に、そのロジックを集約させる
*   `Apollo` の mutation input に依存するメソッドを持つ

# UI

## 設計指針

*   コンポーネント指向の設計を行う
*   UIに関するロジックは親階層(Container Component)、もしくは `Custom Hooks` に可能な限り集約する
*   複雑なUIロジック、もしくはその共通化できるものについては `Custom Hooks` に切り出す。
    *   テスタビリティの向上
    *   コンポーネントの可読性の向上
    *   `Service` の Hook と区別するために、service は `useHogeService` などの命名などをするとよい

## アーキテクチャルール

*   Hooks
    *   状態によって振る舞いを影響を受ける範囲を制限する(状態に関係ない粒度でメソッドを分割する)
*   Component
    *   `Container`、 `Page-ui-parts`, `General-parts`, `Atom` などの粒度で責務を分け、整理する

